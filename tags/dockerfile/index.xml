<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dockerfile on XLabs</title><link>https://www.xlabs.club/tags/dockerfile/</link><description>Recent content in Dockerfile on XLabs</description><generator>Hugo</generator><language>zh</language><copyright>Copyright (c) 2020-2025 XLabs Club</copyright><lastBuildDate>Fri, 19 Dec 2025 15:07:22 +0800</lastBuildDate><atom:link href="https://www.xlabs.club/tags/dockerfile/index.xml" rel="self" type="application/rss+xml"/><item><title>容器镜像制作最佳实践，多架构编译，Dockerfile 编写小技巧和踩坑记录，镜像维护辅助工具 ORAS、skopeo 等介绍</title><link>https://www.xlabs.club/blog/docker-best-practices/</link><pubDate>Fri, 24 May 2024 20:56:08 +0800</pubDate><guid>https://www.xlabs.club/blog/docker-best-practices/</guid><description>&lt;p&gt;汇总整理了容器镜像制作最佳实践、多架构编译、Dockerfile 编写小技巧等常用技术问题，同时介绍下我日常使用的 ORAS、skopeo 等辅助工具。&lt;/p&gt;
&lt;h2 id="最佳实践"&gt;最佳实践&lt;/h2&gt;
&lt;p&gt;整理了由 Docker 官方和社区推荐的用于构建高效镜像的最佳实践和方法，当然有些可能并不适用于你，请注意分辨。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用官方镜像作为基础镜像。官方镜像经过了充分验证并集成了最佳实践。&lt;/p&gt;



&lt;div class="expressive-code"&gt;
 &lt;figure class="frame not-content"&gt;
 &lt;figcaption class="header"&gt;
 &lt;span class="title"&gt;&lt;/span&gt;
 &lt;/figcaption&gt;
 &lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-dockerfile" data-lang="dockerfile"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 正例：&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt; FROM node&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="c"&gt;# 反例：&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt; FROM ubuntu&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt; RUN apt-get install -y node&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
 &lt;/figure&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保持尽可能小的镜像大小，绝不安装无关依赖。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;严格的版本化管理，使用确定性的标签，基础镜像禁用 latest。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 .dockerignore 文件排除文件干扰。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最经常变化的命令越往后执行，充分利用分层缓存机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dockerfile 中每行命令产生一层，请合并命令执行，最大限度减少层数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用多阶段构建，减少所构建镜像的大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;禁用 root 用户，使用独立的 use 和 group。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启用镜像安全扫描，并及时更新。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个容器只专注做一件事情。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java 应用程序不要使用 PID 为 1 的进程，使用 tini 或 dump-init 管理进程，避免僵尸进程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上都是一些基本的原则，但是实际工作的过程中，大家可能会像我一样纠结几个问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关于第 1 点，一定要使用官方镜像吗。未必，看情况。比如我们作为平台，涉及很多种开发语言，很多种组合场景，每个官方基础镜像可能都不同，就会自建基础镜像，以便统一操作系统、统一脚本和安全维护。为什么要统一操作系统，操作系统投的毒，就像出骨鱼片里未净的刺，给人一种不期待的伤痛。&lt;/li&gt;
&lt;li&gt;为了镜像大小和安全，一定要使用 Alpine 或 distroless 镜像吗。我的建议是不要使用 Alpine 镜像，如有能力才使用 distroless 镜像。毕竟 libc 的坑，谁痛谁知道。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="dockerfile-编写小技巧"&gt;Dockerfile 编写小技巧&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 Heredocs 语法代替又长又臭的字符串拼接，当然 Heredocs 支持更多功能比如 run python、多文件内容拷贝，具体请参考官方文档。&lt;/p&gt;</description></item></channel></rss>