<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on XLabs</title><link>https://www.xlabs.club/tags/java/</link><description>Recent content in Java on XLabs</description><generator>Hugo</generator><language>zh</language><copyright>Copyright (c) 2020-2025 XLabs Club</copyright><lastBuildDate>Sat, 06 Dec 2025 10:28:47 +0800</lastBuildDate><atom:link href="https://www.xlabs.club/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Javax 和 Jakarta 过渡期兼容方案</title><link>https://www.xlabs.club/blog/javax-jakarta-compatibility/</link><pubDate>Sun, 14 Sep 2025 14:33:23 +0800</pubDate><guid>https://www.xlabs.club/blog/javax-jakarta-compatibility/</guid><description>&lt;h2 id="什么是-jakarta-ee为什么要切换"&gt;什么是 Jakarta EE，为什么要切换&lt;/h2&gt;
&lt;p&gt;Jakarta EE 就是 Java EE 的新名词。这里的 EE 全称是 Enterprise Edition，它是专门为企业级 Java 应用定义的一套规范，与 Java SE (Java Platform, Standard Edition) 相对应。&lt;/p&gt;
&lt;p&gt;Java EE 是从 Java 1.2 版本开始推出的 Java 企业级开发平台，最初的名称是 J2EE (Java 2 Platform, Enterprise Edition)。随着 Java 的发展，它的名称于 Java 1.5 版本时更改为 Java EE (Java Platform, Enterprise Edition)。2009 年 Oracle 收购了 Sun，Java EE 开始由 Oracle 通过 JCP (Java Community Process) 开发和维护。&lt;/p&gt;
&lt;p&gt;直到 2017 年，Oracle 将 Java EE 提交给了 Eclipse 基金会，并命名为 Eclipse Enterprise for Java。然而，&lt;strong&gt;由于&amp;quot;Java&amp;quot;这个名字的商标归 Oracle 所有，Eclipse 基金会无法继续使用 &lt;code&gt;javax.*&lt;/code&gt; 和 &lt;code&gt;java.*&lt;/code&gt;，因此，项目名称改为 Jakarta EE&lt;/strong&gt;。&lt;/p&gt;</description></item><item><title>CI: Maven 如何在编译时禁止调用某些特定 API</title><link>https://www.xlabs.club/blog/ci-maven-forbidden-api/</link><pubDate>Tue, 09 Sep 2025 22:18:59 +0800</pubDate><guid>https://www.xlabs.club/blog/ci-maven-forbidden-api/</guid><description>&lt;p&gt;在日常开发中，我们经常遇到类似如下需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;项目组提供了 SDK，某个 API 已经被标记为废弃，但是大家迟迟不升级，项目组还需要花费时间维护已经废弃的 API。&lt;/li&gt;
&lt;li&gt;有些项目在使用 JDK 已经废弃的 API，这些废弃 API 在更高版本 JDK 中已经删除，导致推动升级 JDK 比较困难。&lt;/li&gt;
&lt;li&gt;有些项目会跨版本混合编译，比如用 Java 8 编译运行在 Java 21 上，常见的错误比如 &lt;code&gt;javafx.util&lt;/code&gt; 在 Java 21 默认已经去掉了，就会出现编译成功却运行时失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以我们想提供一种方案，能不能在编译期就强制禁用某些 API，主动阻止让编译不通过，提前报错及早发现及早处理。&lt;/p&gt;
&lt;h2 id="实现方案"&gt;实现方案&lt;/h2&gt;
&lt;p&gt;当前我们使用 maven &lt;a href="https://github.com/policeman-tools/forbidden-apis" target="_blank" rel="noopener"&gt;forbiddenapis&lt;/a&gt;
 插件，结合 CI 流程来实现。&lt;/p&gt;
&lt;p&gt;执行效果，如果有使用禁用的 API，能看到类似如下错误提示，编译失败并给出原因。&lt;/p&gt;



&lt;div class="expressive-code"&gt;
 &lt;figure class="frame not-content"&gt;
 &lt;figcaption class="header"&gt;
 &lt;span class="title"&gt;&lt;/span&gt;
 &lt;/figcaption&gt;
 &lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-console" data-lang="console"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;12:40:30.647 [INFO]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;12:40:30.648 [INFO] --- forbiddenapis:3.9:check (check-forbidden-apis) @ app-biz ---
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;12:40:30.657 [INFO] Scanning for classes to check...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;12:40:30.661 [INFO] Reading bundled API signatures: jdk-deprecated-1.8
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;12:40:30.694 [INFO] Reading API signatures: /usr/share/maven/conf/forbidden-apis.txt
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;12:40:30.694 [INFO] Loading classes to check...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;12:40:30.695 [INFO] Scanning classes for violations...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;12:40:30.849 [ERROR] Forbidden class/interface use: javafx.util.Pair [禁止使用 JavaFX 相关类]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;12:40:30.850 [ERROR] in com.tester.HomeController (HomeController.java:11)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;12:40:30.865 [ERROR] Scanned 13 class file(s) for forbidden API invocations (in 0.21s), 1 error(s).
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;12:40:30.872 [INFO] ------------------------------------------------------------------------
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;&lt;/span&gt;&lt;span class="err"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;&lt;/span&gt;&lt;span class="go"&gt;24784 [INFO] --- forbiddenapis:3.9:check (check-forbidden-apis) @ app-api ---
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;24812 [INFO] Scanning for classes to check...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;24884 [INFO] Reading bundled API signatures: jdk-deprecated-1.8
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;25016 [INFO] Reading API signatures: /usr/share/maven/conf/forbidden-apis.txt
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;25017 [INFO] Loading classes to check...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;25106 [INFO] Scanning classes for violations...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;25984 [ERROR] Forbidden method invocation: java.net.URLEncoder#encode(java.lang.String) [Deprecated in Java 1.8]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;25984 [ERROR] in com.tester.FormBody$FormBodyBuilder (FormBody.java:60)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;26110 [ERROR] Scanned 660 class file(s) for forbidden API invocations (in 1.31s), 2 error(s).
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;26113 [INFO]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
 &lt;/figure&gt;
&lt;/div&gt;
&lt;h3 id="maven-核心配置"&gt;Maven 核心配置&lt;/h3&gt;
&lt;p&gt;首先，在父 pom 里增加了以下片段，此内容主要含义：&lt;/p&gt;</description></item><item><title>Koupleless 试用报告总结，踩坑记录分享</title><link>https://www.xlabs.club/blog/koupleless-first-boot/</link><pubDate>Mon, 27 May 2024 14:20:24 +0800</pubDate><guid>https://www.xlabs.club/blog/koupleless-first-boot/</guid><description>&lt;p&gt;我们公司的主要应用都是以 Java 作为开发语言，这几年随着业务的高速增长，应用数目越来越多，CPU 内存资源占用越来越多，项目组之间开发合作效率也越来越低。&lt;/p&gt;
&lt;p&gt;顺应这个时代降本增效的目的，我们希望寻找一个能解决当前几个核心问题的框架：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模块化开发、部署、资源共享的能力，减少 Cache、Class 等资源占用，有效降低内存占用。&lt;/li&gt;
&lt;li&gt;更快更轻的依赖，应用能够更快的启动。&lt;/li&gt;
&lt;li&gt;能够让各个项目组不改代码或少改代码即可接入，控制开发迁移的成本，毕竟很多历史老应用不是那么容易迁移。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于以上背景，我们在 2022 年基于 SOFAArk 运行了一个版本，效果不太理想暂时搁置。今年 Koupleless 重新开源后做了一些增强和变更，开源社区活跃度有所提升，看宣传效果很好，我们决定重新评估是否可在公司内推广。&lt;/p&gt;
&lt;h2 id="什么是-koupleless"&gt;什么是 Koupleless&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://koupleless.io/home/" target="_blank" rel="noopener"&gt;Koupleless&lt;/a&gt;
 是一种模块化 Serverless 技术解决方案，它能让普通应用低成本演进为 Serverless 研发模式，让代码与资源解耦，轻松独立维护， 与此同时支持秒级构建部署、合并部署、动态伸缩等能力为用户提供极致的研发运维体验，最终帮助企业实现降本增效。&lt;/p&gt;
&lt;p&gt;Koupleless 是蚂蚁集团内部经过 5 年打磨成熟的研发框架和运维调度平台能力，相较于传统镜像化的应用模式研发、运维、运行阶段都有 10 倍左右的提升，总结起来 5 大特点：快、省、灵活部署、平滑演进、生产规模化验证。&lt;/p&gt;
&lt;p&gt;以上都是官网的宣传，更多介绍请链接到官网查看。&lt;/p&gt;
&lt;p&gt;在整个 Koupleless 平台里，需要四个组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;研发工具 Arkctl, 提供模块创建、快速联调测试等能力。&lt;/li&gt;
&lt;li&gt;运行组件 SOFAArk, Arklet，提供模块运维、模块生命周期管理，多模块运行环境。（这算两个组件？）&lt;/li&gt;
&lt;li&gt;控制面组件 ModuleController，本质上是一个 K8S Operator，提供模块发布与运维能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们公司有自己的发布系统、应用管理平台，很少允许运行额外的控制面组件，那么除去 ModuleController，我个人认为，Koupleless 约等于 SOFAArk。&lt;/p&gt;
&lt;p&gt;Koupleless 增强了 SOFAArk 运维部署相关的功能，解决了 SOFAArk 在企业内无法开箱即用的问题。&lt;/p&gt;
&lt;h2 id="应用接入遇见问题"&gt;应用接入遇见问题&lt;/h2&gt;
&lt;p&gt;基于官方文档我们改造接入了几个应用，分享几个我们遇见的问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对 Java 17 或 21 的支持不好。
虽然官方已经声称支持 Java 17，但是若用了 Java 17 的语法或新特性，无法编译通过。最后只好自编译 SOFAArk plugin 修改相关依赖解决。&lt;/p&gt;</description></item><item><title>从 Java 8 升级到 Java 25，踩坑记录、变更评估方法、辅助工具介绍、新特性介绍</title><link>https://www.xlabs.club/blog/migrating-java8-to-java25/</link><pubDate>Thu, 23 May 2024 21:03:11 +0800</pubDate><guid>https://www.xlabs.club/blog/migrating-java8-to-java25/</guid><description>&lt;p&gt;

&lt;img
 src="https://www.xlabs.club/blog/migrating-java8-to-java25/java25_hu_42c3cb3c5a24a2c.webp"
 width="770"
 height="403"
 decoding="async"
 fetchpriority="auto"
 loading="lazy"
 alt="java25-release"title="java25-release"
 id="h-rh-i-0"
&gt;&lt;/p&gt;
&lt;p&gt;虽然 Java 界流行 &lt;strong&gt;你发任你发，我用 Java 8&lt;/strong&gt;。但根据 Azul 组织发布的 &lt;a href="https://www.azul.com/newsroom/azul-2025-state-of-java-survey-report/" target="_blank" rel="noopener"&gt;2025 Java 最新使用报告&lt;/a&gt;
 显示，Java 17 悄悄登上了使用率最高的宝座，Java 21 也紧随其后。
至于新发布的 Java 25， 能不能承担起 &lt;code&gt;Make Java Great Again&lt;/code&gt; 的艰巨任务，还需要时间的考验，让子弹再飞一会。&lt;/p&gt;
&lt;p&gt;

&lt;img
 src="https://www.xlabs.club/blog/migrating-java8-to-java25/java-report_hu_cf024fc5f59d1d32.webp"
 width="1080"
 height="609"
 decoding="async"
 fetchpriority="auto"
 loading="lazy"
 alt="java-report"title="java-report"
 id="h-rh-i-1"
&gt;&lt;/p&gt;
&lt;p&gt;今天我们将介绍下，从 Java 8 到 Java 25，有哪些新特性，有什么工具可协助升级，以及在升级过程中遇到的问题和解决办法。&lt;/p&gt;
&lt;h2 id="令人心动的特性"&gt;令人心动的特性&lt;/h2&gt;
&lt;p&gt;下图展示了自 Java 8 以来每个 Java 版本中的 JEP（JDK Enhancement Proposal，即 JDK 增强提案） 数量，下面将摘出几个比较令人心动且使用频率较高的特性进行介绍。&lt;/p&gt;
&lt;p&gt;

&lt;img
 src="https://www.xlabs.club/blog/migrating-java8-to-java25/java-jep_hu_4ab27b0d4e441598.webp"
 width="1724"
 height="970"
 decoding="async"
 fetchpriority="auto"
 loading="lazy"
 alt="java-jep"title="java-jep"
 id="h-rh-i-2"
&gt;&lt;/p&gt;
&lt;h3 id="语法糖"&gt;语法糖&lt;/h3&gt;
&lt;p&gt;语法糖特性让代码编写更加简洁优雅，提升开发体验。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;集合 &amp;amp;&amp;amp; Stream API 增强&lt;/strong&gt; - Java 8/9/12/16/21&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Java 8 引入 Stream API，支持函数式数据处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java 9 新增 &lt;code&gt;dropWhile()&lt;/code&gt;、&lt;code&gt;takeWhile()&lt;/code&gt;、&lt;code&gt;iterate()&lt;/code&gt; 增强、&lt;code&gt;ofNullable()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java 12 新增 &lt;code&gt;Collectors.teeing()&lt;/code&gt; 方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Java 16 新增 &lt;code&gt;Stream.toList()&lt;/code&gt; 和 &lt;code&gt;mapMulti()&lt;/code&gt; 方法&lt;/p&gt;</description></item><item><title>Spring Boot Start 脚手架定制开发和快速入门</title><link>https://www.xlabs.club/blog/spring-boot-start-site/</link><pubDate>Sat, 09 Mar 2024 14:29:03 +0800</pubDate><guid>https://www.xlabs.club/blog/spring-boot-start-site/</guid><description>&lt;p&gt;介绍基于 &lt;code&gt;start.spring.io&lt;/code&gt; 快速定制自己的 Spring Boot 脚手架，主要应用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;规范公司自己的 parent pom，增加特定的依赖项。&lt;/li&gt;
&lt;li&gt;根据公司规范生成统一的包结构，统一命名。&lt;/li&gt;
&lt;li&gt;根据需要增加特定代码或文件，比如根据公司要求统一 logback.xml、 application.properties 文件。&lt;/li&gt;
&lt;li&gt;提供公司自研的二方 jar 包。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="快速开始"&gt;快速开始&lt;/h2&gt;
&lt;p&gt;基本步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于 &lt;a href="https://github.com/spring-io/initializr" target="_blank" rel="noopener"&gt;spring.initializr&lt;/a&gt;
 我们没有定制的需求，直接引用官方的。&lt;/li&gt;
&lt;li&gt;拷贝一份 &lt;a href="https://github.com/spring-io/start.spring.io" target="_blank" rel="noopener"&gt;start.spring.io&lt;/a&gt;
，直接基于这个项目开发、部署、运行。以下都是关于如何修改 &lt;code&gt;start.spring.io&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;start.spring.io&lt;/code&gt; 主要关注两个模块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;start-client：前端页面，可以定制些自己的 logo、title 等。&lt;/li&gt;
&lt;li&gt;start-site：是一个标准的 spring boot 项目，实际 run 起来的服务，引用了 start-client，直接 run 这个项目的 main 方法就能看到效果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主要配置文件：&lt;code&gt;start-site/src/main/resources/application.yml&lt;/code&gt;，通过修改这个配置文件可以达到的效果如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;修改 start 启动时默认 group，把 &lt;code&gt;com.example&lt;/code&gt; 改为公司自己的 group。&lt;/p&gt;



&lt;div class="expressive-code"&gt;
 &lt;figure class="frame not-content"&gt;
 &lt;figcaption class="header"&gt;
 &lt;span class="title"&gt;&lt;/span&gt;
 &lt;/figcaption&gt;
 &lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-yaml" data-lang="yaml"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nt"&gt;initializr&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;group-id&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;value&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l"&gt;com.yourgroup&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
 &lt;/figure&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改父 pom，使用公司自己的 pom。&lt;/p&gt;



&lt;div class="expressive-code"&gt;
 &lt;figure class="frame not-content"&gt;
 &lt;figcaption class="header"&gt;
 &lt;span class="title"&gt;&lt;/span&gt;
 &lt;/figcaption&gt;
 &lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-yaml" data-lang="yaml"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nt"&gt;initializr&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;env&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;maven&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c"&gt;# use your parent pom&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;groupId&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l"&gt;com.yourself&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;artifactId&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l"&gt;your-parent&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1.0.0&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c"&gt;# relativePath: ../pom.xml&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;includeSpringBootBom&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
 &lt;/figure&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;限定 Java 和 Spring Boot 版：修改 languages 和 bootVersions 即可。&lt;/p&gt;</description></item><item><title>基于 Alibaba Sentinel 实现的分布式限流中间件服务以及遇到的坑和注意事项</title><link>https://www.xlabs.club/blog/sentinel/</link><pubDate>Thu, 07 Mar 2024 21:06:10 +0800</pubDate><guid>https://www.xlabs.club/blog/sentinel/</guid><description>&lt;p&gt;基于 Alibaba Sentinel 实现的分布式限流中间件服务。主要对服务提供者提供限流、系统保护，对服务调用者提供熔断降级、限流排队等待效果。&lt;/p&gt;
&lt;p&gt;实现目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作为服务提供者，保护自己不被打死，服务可以慢不可以挂。&lt;/li&gt;
&lt;li&gt;作为客户端及时限速和熔断，防止对服务提供方包含 Http、数据库、MQ 等造成太大压力，防止把糟糕的情况变得更糟。&lt;/li&gt;
&lt;li&gt;以用户、租户、对象等更细粒度进行流量精细控制。&lt;/li&gt;
&lt;li&gt;服务预热，应用新发布上线，缓存尚未完全建立，防止流量一下子把服务打死。&lt;/li&gt;
&lt;li&gt;能够根据 Prometheus、ClickHouse、Elasticsearch 提供的监控指标，动态生成规则，自适应调整规则。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="概述"&gt;概述&lt;/h2&gt;
&lt;p&gt;Sentinel 的基础知识请参考官方文档描述，这里单独介绍一些与我们定制相关的内容。&lt;/p&gt;
&lt;p&gt;限流简单来说就三个点：资源、规则、效果。&lt;/p&gt;
&lt;p&gt;资源：就是一个字符串，这个字符串可以自己定义、可以用注解自动生成、可以通过拦截器按规则生成。&lt;/p&gt;
&lt;p&gt;规则：Sentinel 定义的一系列限流保护规则，比如流量控制规则、自适应保护规则。&lt;/p&gt;
&lt;p&gt;效果：实际上“效果”也是“规则”定义的一部分。任何一条请求，命中某些资源规则后产生的效果，比如直接抛出异常、匀速等待。&lt;/p&gt;
&lt;h3 id="sentinel-全局注意事项和使用限制"&gt;Sentinel 全局注意事项和使用限制&lt;/h3&gt;
&lt;p&gt;使用开源默认 Sentinel 组件，有一些坑，或者说需要关注的注意事项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单个进程内资源数量阈值是 6000，多出的资源规则将不会生效（因为是懒加载，资源先到先得），也不提示错误而是直接忽略，资源数量太多建议使用热点参数控制。&lt;/li&gt;
&lt;li&gt;对于限流的链路模式，context 阈值是 2000，所以默认的 WEB_CONTEXT_UNIFY 为 true，如果需要链路限流需要把这个改为 false。&lt;/li&gt;
&lt;li&gt;自定义时，资源名中不要带 &lt;code&gt;|&lt;/code&gt; 线， 这个日志中要用，日志以此作为分割符。&lt;/li&gt;
&lt;li&gt;Sentinel 支持按来源限流，注意 &lt;code&gt;origin&lt;/code&gt; 数量不能太多，否则会导致内存暴涨。&lt;/li&gt;
&lt;li&gt;一个资源可以有多个规则，一条请求能否通过，取决于规则里阈值最小的限制条件。&lt;/li&gt;
&lt;li&gt;限流的目的是保护系统，计数计量并不准确，所以不要拿限流做计量或配额控制。&lt;/li&gt;
&lt;li&gt;增加限流一定程度上通过时间换空间，降低了 CPU、内存负载，对 K8S HPA 策略会有一定影响。后续我们也会考虑根据 Sentinel 限流指标进行扩缩容。&lt;/li&gt;
&lt;li&gt;限流中如果有增加等待效果会使接口变慢，各调用链需要关注调用超时和事务配置。&lt;/li&gt;
&lt;li&gt;目前 sentinel-web-servlet 和 sentinel-spring-webmvc-adapter 均不支持热点参数限流。为了支持热点参数需要自行扩展。&lt;/li&gt;
&lt;li&gt;sentinel-web-servlet 和 sentinel-spring-webmvc-adapter 会将每个到来的不同的 URL 都作为不同的资源处理，因此对于 REST 风格的 API，需要自行实现 UrlCleaner 接口清洗一下资源（比如将满足 /foo/:id 的 URL 都归到 /foo/* 资源下）。否则会导致资源数量过多，超出资源数量阈值（目前是 6000）时多出的资源的规则将不会生效。&lt;/li&gt;
&lt;li&gt;Java 中 &lt;code&gt;sentinel-time-tick-thread&lt;/code&gt; 线程会额外多占用约 1-2% CPU，详细代码参考 &lt;code&gt;com.alibaba.csp.sentinel.util.TimeUtil&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一些文档中尚未更新但是大家可能关心的内容：&lt;/p&gt;</description></item><item><title>重复 Transfer-Encoding Response Header 引起的 Traefik 代理服务 500 问题</title><link>https://www.xlabs.club/blog/duplicate-transfer-encoding-chunked/</link><pubDate>Sun, 26 Nov 2023 10:21:44 +0800</pubDate><guid>https://www.xlabs.club/blog/duplicate-transfer-encoding-chunked/</guid><description>&lt;p&gt;我有一个 Spring Boot 应用服务，提供了一些简单的查询接口，本身运行很正常，通过 curl 或其他 http 客户端 localhost 请求都没有问题。&lt;/p&gt;
&lt;p&gt;某天通过 Traefik 代理了此服务，经过代理后再访问，某个接口一直都是 &lt;code&gt;500 internal server error&lt;/code&gt;，其他接口都没有问题。通过 tcpdump 抓包发现，应用服务并没有返回任何 500 错误，而且响应时间和 Body 体大小都很正常。&lt;/p&gt;
&lt;p&gt;根据网上经验排查了 Traefik SSL 证书问题、路径问题、消息体太大问题、请求 Header 不合规问题，都一一否定。最后无意间看了一眼 Response Header，发现 Spring Boot 应用返回了两个 &lt;code&gt;Transfer-Encoding: chunked&lt;/code&gt; Header。&lt;/p&gt;
&lt;p&gt;再根据此 Header 搜索，发现果然有人遇到过类似问题，请参考这几个链接。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/traefik/traefik/issues/7741" target="_blank" rel="noopener"&gt;https://github.com/traefik/traefik/issues/7741&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/spring-projects/spring-framework/issues/21523" target="_blank" rel="noopener"&gt;https://github.com/spring-projects/spring-framework/issues/21523&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/spring-projects/spring-boot/issues/37646" target="_blank" rel="noopener"&gt;https://github.com/spring-projects/spring-boot/issues/37646&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/77042701/nginx-upstream-sent-duplicate-header-line-transfer-encoding-chunked-previo" target="_blank" rel="noopener"&gt;https://stackoverflow.com/questions/77042701/nginx-upstream-sent-duplicate-header-line-transfer-encoding-chunked-previo&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面链接描述中可知，不仅 Traefik 会出现此问题，nginx 包含以 nginx 为基础的 ingress 也会出现同样问题，不过 nginx 返回错误信息类似 &lt;code&gt;Nginx: upstream sent duplicate header line: &amp;quot;Transfer-Encoding: chunked&amp;quot;, previous value: &amp;quot;Transfer-Encoding: chunked”&lt;/code&gt; ，返回错误码一般是 502 Bad Gateway。&lt;/p&gt;</description></item><item><title>K8S 容器 PID 限制引起的 Java OutOfMemoryError</title><link>https://www.xlabs.club/blog/k8s-pid-limiting-oom/</link><pubDate>Thu, 07 Sep 2023 16:21:44 +0800</pubDate><guid>https://www.xlabs.club/blog/k8s-pid-limiting-oom/</guid><description>&lt;p&gt;问题描述：&lt;/p&gt;
&lt;p&gt;一个 Java 应用跑在 K8S 容器内，Pod 内只有 Java 这一个进程。应用跑了一段时间后，CPU、内存占用都不高，但是却出现以下 OutOfMemoryError 错误。&lt;/p&gt;



&lt;div class="expressive-code"&gt;
 &lt;figure class="frame not-content"&gt;
 &lt;figcaption class="header"&gt;
 &lt;span class="title"&gt;&lt;/span&gt;
 &lt;/figcaption&gt;
 &lt;div class="highlight"&gt;&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-console" data-lang="console"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;Exception in thread &amp;#34;slow-fetch-15&amp;#34; java.lang.OutOfMemoryError: unable to create new native thread
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;428 at java.lang.Thread.start0(Native Method)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;429 at java.lang.Thread.start(Thread.java:719)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;430 at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:957)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;431 at java.util.concurrent.ThreadPoolExecutor.processWorkerExit(ThreadPoolExecutor.java:1025)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;432 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="go"&gt;433 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
 &lt;/figure&gt;
&lt;/div&gt;
&lt;p&gt;进入 Pod 内，尝试执行任何操作，又会出现 &lt;code&gt;unable to start container process&lt;/code&gt; 错误。&lt;/p&gt;
&lt;p&gt;一开始怀疑是内存不足，调大了内存，同时也缩小了 Java 的 &lt;code&gt;xss&lt;/code&gt;，都不起作用。&lt;/p&gt;
&lt;p&gt;真实原因： K8S 容器限制了 PID 数，无法创建新的线程。关于 K8S PID limit， 可参考此资料：&lt;a href="https://kubernetes.io/zh-cn/docs/concepts/policy/pid-limiting/" target="_blank" rel="noopener"&gt;https://kubernetes.io/zh-cn/docs/concepts/policy/pid-limiting/&lt;/a&gt;
.&lt;/p&gt;
&lt;p&gt;在 Pod 内查看当前 PID 限制方式：&lt;/p&gt;</description></item><item><title>K8S Pod 容器内 Java 进程内存分析，内存虚高以及容器 OOM 或 Jave OOM 问题定位</title><link>https://www.xlabs.club/blog/java-memory/</link><pubDate>Sat, 07 Jan 2023 10:54:37 +0800</pubDate><guid>https://www.xlabs.club/blog/java-memory/</guid><description>&lt;p&gt;故事背景：&lt;/p&gt;
&lt;p&gt;一个 K8S Pod，里面只有一个 Java 进程，K8S request 和 limit memory 都是 2G，Java 进程核心参数包括：&lt;code&gt;-XX:+UseZGC -Xmx1024m -Xms768m&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;服务启动一段时间后，查看 Grafana 监控数据，Pod 内存使用量约 1.5G，JVM 内存使用量约 500M，通过 jvm dump 分析没有任何大对象，运行三五天后出现 K8S Container OOM。&lt;/p&gt;
&lt;p&gt;首先区分下 Container OOM 和 Jvm OOM，Container OOM 是 Pod 内进程申请内存大约 K8S Limit 所致。&lt;/p&gt;
&lt;p&gt;问题来了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Pod 2G 内存，JVM 设置了 &lt;code&gt;Xmx 1G&lt;/code&gt;，已经预留了 1G 内存，为什么还会 Container OOM，这预留的 1G 内存被谁吃了。&lt;/li&gt;
&lt;li&gt;正常情况下（无 Container OOM），Grafana 看到的监控数据，Pod 内存使用量 1.5G， JVM 内存使用量 500M，差别为什么这么大。&lt;/li&gt;
&lt;li&gt;Pod 内存使用量为什么超过 Xmx 限制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Grafana 监控图。&lt;/p&gt;
&lt;p&gt;&lt;a href="./grafana-pod-jvm.png"&gt;

&lt;img
 src="https://www.xlabs.club/blog/java-memory/grafana-pod-jvm_hu_f3e003bf88afca3a.webp"
 width="1920"
 height="3600"
 decoding="async"
 fetchpriority="auto"
 loading="lazy"
 alt="Grafana 监控图"
 id="h-rh-i-0"
&gt;&lt;/a&gt;
&lt;/p&gt;</description></item><item><title>Spring Boot 使用 Micrometer 集成 Prometheus 监控，5 分钟接入自定义监控指标</title><link>https://www.xlabs.club/blog/spring-boot-micrometer/</link><pubDate>Mon, 07 Aug 2023 10:54:37 +0800</pubDate><guid>https://www.xlabs.club/blog/spring-boot-micrometer/</guid><description>&lt;p&gt;Spring Boot 使用 Micrometer 集成 Prometheus 监控，5 分钟接入自定义监控指标，主要内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Micrometer 介绍。&lt;/li&gt;
&lt;li&gt;业务如何自定义指标，如何接入 Prometheus，实现方式和规范。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="micrometer-介绍"&gt;Micrometer 介绍&lt;/h2&gt;
&lt;p&gt;Micrometer 为 Java 平台上的性能数据收集提供了一个通用的 API，应用程序只需要使用 Micrometer 的通用 API 来收集性能指标，Micrometer 会负责完成与不同监控系统的适配工作。&lt;/p&gt;
&lt;p&gt;Micrometer 提供了多种度量指标类型（Timers、Guauges、Counters 等），同时支持接入不同的监控系统，例如 Influxdb、Graphite、Prometheus、OTLP 等。&lt;/p&gt;
&lt;p&gt;从 Spring Boot 2.x 开始使用 Micrometer 作为默认的监控门面接口， &lt;code&gt;Think SLF4J, but for observability&lt;/code&gt; 。&lt;/p&gt;
&lt;h3 id="micrometer-核心概念"&gt;Micrometer 核心概念&lt;/h3&gt;
&lt;p&gt;Micrometer 中两个最核心的概念：计量器注册表 (MeterRegistry)，计量器 (Meter)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MeterRegistry&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存注册表 (SimpleMeterRegistry): 在内存中保存每一个 Meter（指标）的最新值，并且不会将数据导出到任何地方。&lt;/li&gt;
&lt;li&gt;组合注册表 (CompositeMeterRegistry): 可以添加多个注册表，用于将各个注册表组合起来，可以同时将指标发布到多个监控系统。Micrometer 提供了一个全局的 MeterRegistry，&lt;code&gt;io.micrometer.core.instrument.Metrics&lt;/code&gt; 中持有一个静态 final 的 CompositeMeterRegistry 实例 globalRegistry。&lt;/li&gt;
&lt;li&gt;普罗米修斯注册表 (PrometheusMeterRegistry): 当使用普罗米修斯监控时，引入 micrometer-registry-prometheus 依赖时会提供此种收集器，用于将指标数据转换为普罗米修斯识别的格式和导出数据等功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Meter（指标）&lt;/p&gt;
&lt;p&gt;监控数据的整个过程都是围绕着 Meter（指标）, 通过一个一个的 Meter（指标）数据来进行观察应用的状态。常用的指标如：&lt;/p&gt;</description></item></channel></rss>