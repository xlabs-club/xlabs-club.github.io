<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Traefik on XLabs</title><link>https://www.xlabs.club/tags/traefik/</link><description>Recent content in Traefik on XLabs</description><generator>Hugo</generator><language>zh</language><copyright>Copyright (c) 2020-2025 XLabs Club</copyright><lastBuildDate>Sun, 28 Dec 2025 11:59:43 +0800</lastBuildDate><atom:link href="https://www.xlabs.club/tags/traefik/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 oauth2-proxy 为任意程序增加认证鉴权，结合 K8S、traefik、keycloak 部署配置详解</title><link>https://www.xlabs.club/blog/traefik-oauth2-proxy-keycloak/</link><pubDate>Thu, 10 Oct 2024 23:30:40 +0800</pubDate><guid>https://www.xlabs.club/blog/traefik-oauth2-proxy-keycloak/</guid><description>&lt;p&gt;作为一个程序员，在日常开发中永远避免不了认证鉴权，而我们开发的某些应用，并不需要太复杂的鉴权，比如可能只要求必须是登录用户，或者只需要根据角色进行 RBAC 鉴权。有没有方法简化此流程，让应用开发者只关注业务开发，这就是本文档要解决的问题。&lt;/p&gt;
&lt;p&gt;如果你有类似以下的需求，都可以参考此文档，原理是一样的，组件也可复用。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为原本没有登录验证的服务提供认证服务，比如某些开源组件不支持认证但是又因携带一些危险数据而不想公开访问。&lt;/li&gt;
&lt;li&gt;实现统一的单点登录 SSO、并支持简单的 RBAC、UBAC 鉴权。&lt;/li&gt;
&lt;li&gt;为 Kubernetus Traefik Nginx Ingress 提供统一的认证入口，一键实现所有入口必须登录才可访问。&lt;/li&gt;
&lt;li&gt;配置 Traefik 使用 Forward Auth，Nginx 使用 auth_request 实现认证，也可以一并参考。&lt;/li&gt;
&lt;li&gt;在 K8S 或应用网关，基于用户、角色等不同属性，路由到不同服务。&lt;/li&gt;
&lt;li&gt;如果你凑巧也在用 &lt;a href="https://backstage.io/" target="_blank" rel="noopener"&gt;Backstage&lt;/a&gt;
，请参考 &lt;a href="https://www.xlabs.club/blog/backstage-oauth2-proxy-keycloak/" target="_blank" rel="noopener"&gt;另一篇博客&lt;/a&gt;
。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;写在前面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本文档里的示例代码是以 k3s 为基础，使用 traefik 作为 ingress controller，整体完善但略显复杂，如果没有 K3S/K8S，以其他方式部署也是完全可以的，基本原理都是一样的。&lt;/li&gt;
&lt;li&gt;对于某些场景下可选的配置，会单独说明，请注意分别。&lt;/li&gt;
&lt;li&gt;这里提到的每个组件都是可替换的，比如 nginx 代替 traefik，Pomerium 代替 oauth2-proxy，可根据爱好选择，后面也会适当补充几种不同方式的对比和部署差异，更详细内容请参考本站另外一篇文档 &lt;a href="https://www.xlabs.club/docs/platform/iam/" target="_blank" rel="noopener"&gt;统一身份认证&lt;/a&gt;
。&lt;/li&gt;
&lt;li&gt;示例中的代码都是从真实环境拷贝经过检验的，但为了便于理解可能裁剪无关紧要的内容，完整的安装部署源码请参考我们的部署脚本 &lt;a href="https://github.com/xlabs-club/xlabs-ops" target="_blank" rel="noopener"&gt;xlabs-club/xlabs-ops&lt;/a&gt;
。&lt;/li&gt;
&lt;li&gt;需要懂一些 K8S、OIDC 基础知识，此处只提供链接不展开说明。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="组件介绍"&gt;组件介绍&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Keycloak&lt;/p&gt;
&lt;p&gt;Keycloak 是一个开源的身份和访问管理解决方案，支持 OAuth 2.0、OpenID Connect、SAML 等协议。它提供用户管理、角色管理、单点登录（SSO）、身份提供服务等功能，在本示例中担任 Auth Provider 角色。关于 Keycloak 的中文介绍，可参考本站单独的博客 &lt;a href="https://idaas.xlabs.club/" target="_blank" rel="noopener"&gt;IDaaS Book&lt;/a&gt;
。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://oauth2-proxy.github.io/oauth2-proxy/" target="_blank" rel="noopener"&gt;oauth2-proxy&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;顾名思义它是一个关于 oauth 反向代理，主要用来为后端服务增加身份验证层。它支持多种 OAuth 2.0 提供者（如 Google、OIDC、Keycloak 等），可以保护未提供身份验证的应用。oauth2-proxy 在请求进入后端服务之前，会先进行 OAuth 2.0 登录认证，确保请求者具有访问权限。它承担了登录的合法性校验、重定向、登录成功后的 cookie、response 设置等功能。&lt;/p&gt;</description></item><item><title>重复 Transfer-Encoding Response Header 引起的 Traefik 代理服务 500 问题</title><link>https://www.xlabs.club/blog/duplicate-transfer-encoding-chunked/</link><pubDate>Sun, 26 Nov 2023 10:21:44 +0800</pubDate><guid>https://www.xlabs.club/blog/duplicate-transfer-encoding-chunked/</guid><description>&lt;p&gt;我有一个 Spring Boot 应用服务，提供了一些简单的查询接口，本身运行很正常，通过 curl 或其他 http 客户端 localhost 请求都没有问题。&lt;/p&gt;
&lt;p&gt;某天通过 Traefik 代理了此服务，经过代理后再访问，某个接口一直都是 &lt;code&gt;500 internal server error&lt;/code&gt;，其他接口都没有问题。通过 tcpdump 抓包发现，应用服务并没有返回任何 500 错误，而且响应时间和 Body 体大小都很正常。&lt;/p&gt;
&lt;p&gt;根据网上经验排查了 Traefik SSL 证书问题、路径问题、消息体太大问题、请求 Header 不合规问题，都一一否定。最后无意间看了一眼 Response Header，发现 Spring Boot 应用返回了两个 &lt;code&gt;Transfer-Encoding: chunked&lt;/code&gt; Header。&lt;/p&gt;
&lt;p&gt;再根据此 Header 搜索，发现果然有人遇到过类似问题，请参考这几个链接。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/traefik/traefik/issues/7741" target="_blank" rel="noopener"&gt;https://github.com/traefik/traefik/issues/7741&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/spring-projects/spring-framework/issues/21523" target="_blank" rel="noopener"&gt;https://github.com/spring-projects/spring-framework/issues/21523&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/spring-projects/spring-boot/issues/37646" target="_blank" rel="noopener"&gt;https://github.com/spring-projects/spring-boot/issues/37646&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/77042701/nginx-upstream-sent-duplicate-header-line-transfer-encoding-chunked-previo" target="_blank" rel="noopener"&gt;https://stackoverflow.com/questions/77042701/nginx-upstream-sent-duplicate-header-line-transfer-encoding-chunked-previo&lt;/a&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从上面链接描述中可知，不仅 Traefik 会出现此问题，nginx 包含以 nginx 为基础的 ingress 也会出现同样问题，不过 nginx 返回错误信息类似 &lt;code&gt;Nginx: upstream sent duplicate header line: &amp;quot;Transfer-Encoding: chunked&amp;quot;, previous value: &amp;quot;Transfer-Encoding: chunked”&lt;/code&gt; ，返回错误码一般是 502 Bad Gateway。&lt;/p&gt;</description></item></channel></rss>